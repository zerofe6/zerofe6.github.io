{"meta":{"title":"bofan's blog","subtitle":"","description":"","author":"范博","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-01-10T07:48:47.000Z","updated":"2020-01-10T07:48:47.677Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-10T07:47:00.000Z","updated":"2020-01-10T07:47:00.390Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-10T07:48:33.000Z","updated":"2020-01-10T07:48:33.095Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL基础-DQL-排序查询","slug":"MySQL基础-DQL-排序查询","date":"2020-07-22T09:53:55.000Z","updated":"2020-07-22T10:02:26.599Z","comments":true,"path":"2020/07/22/MySQL基础-DQL-排序查询/","link":"","permalink":"http://yoursite.com/2020/07/22/MySQL%E5%9F%BA%E7%A1%80-DQL-%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"MySQL排序_DQL示例表员工表：员工编号、名、姓 、邮箱、电话号码、工种编号、薪水、奖金率、上级领导员工编号、部门编号、入职日期 部门表：部门编号、部门名称、部门领导的员工编号、位置编号 位置表：位置编号、街道、邮编、城市、省份、国家编号 工种表：工种编号、工种名称、最低工资、最高工资 排序查询1、引入 select * from employees;2、语法 select 查询列表 from 表 where 筛选条件 order by 排序列表【asc | desc】 3、特点： 1.asc代表升序 desc 代表降序 不写默认升序 2.order by 字句中可以支持单个字段、多个字段、表达式、函数、别名 3.order by 字句一般放在查询语句的最后面，但limit子句除外 案例一：查询员工信息 工资从高到低实现排序select * from employees ORDER BY salary desc; select * from employees ORDER BY salary asc; 案例二：查询部门编号大于等于90的员工信息，按入职时间先后进行排序select * FROM employees where department_id&gt;=90 ORDER BY hiredate asc; 案例三：按表达式排序 按员工的年薪高低显示员工的年薪和信息SELECT *, salary * 12 *(1+IFNULL(commission_pct,0)) as 年薪 FROM employees ORDER BY salary * 12 *(1+IFNULL(commission_pct,0)) desc; 案例四：按别名排序SELECT *, salary * 12 *(1+IFNULL(commission_pct,0)) as 年薪 FROM employees ORDER BY 年薪 desc; 案例五：按姓名长度显示员工的姓名和工资【按函数排序】SELECT LENGTH(last_name) as 姓名长度, last_name as 姓名, salary as 工资 from employees ORDER BY 姓名长度 asc; 案例六：查询员工信息，先按工资升序排序再按员工编号降序排序【按多个字段排序】也就说 按工资排序 工资一样的时候 在按员工编号降序排序select salary as 员工工资, employee_id as 员工编号 FROM employees ORDER BY salary asc, employee_id desc; 案例四：按别名排序SELECT *, salary * 12 *(1+IFNULL(commission_pct,0)) as 年薪 FROM employees ORDER BY 年薪 desc; 案例四：按别名排序SELECT *, salary * 12 *(1+IFNULL(commission_pct,0)) as 年薪 FROM employees ORDER BY 年薪 desc; 案例四：按别名排序SELECT *, salary * 12 *(1+IFNULL(commission_pct,0)) as 年薪 FROM employees ORDER BY 年薪 desc; 作业测试#测试一：查询员工的姓名、部门号 和年薪 按年薪降序、姓名升序 SELECT last_name as 姓名, department_id as 部门号, salary*12*(1+IFNULL(commission_pct,0)) 年薪 from employees ORDER BY 年薪 desc , 姓名 asc; #测试二：选择工资不在8000到17000的员工工资和姓名，按工资降序 SELECT salary as 工资, last_name as 姓名 FROM employees WHERE salary not BETWEEN 8000 and 17000 ORDER BY salary desc; #测试三：查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序 SELECT *, LENGTH(employees.email) as 邮箱字节数 FROM employees WHERE email like &#39;%e%&#39; ORDER BY 邮箱字节数 desc ,department_id asc;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"MySQL基础-DQL-条件查询","slug":"MySQL基础-DQL-条件查询-1","date":"2020-07-22T09:53:19.000Z","updated":"2020-07-22T09:53:19.047Z","comments":true,"path":"2020/07/22/MySQL基础-DQL-条件查询-1/","link":"","permalink":"http://yoursite.com/2020/07/22/MySQL%E5%9F%BA%E7%A1%80-DQL-%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2-1/","excerpt":"","text":"","categories":[],"tags":[{"name":"xxx","slug":"xxx","permalink":"http://yoursite.com/tags/xxx/"}]},{"title":"MySQL基础-DQL-条件查询","slug":"MySQL基础-DQL-条件查询","date":"2020-07-22T08:39:36.000Z","updated":"2020-07-22T08:40:39.670Z","comments":true,"path":"2020/07/22/MySQL基础-DQL-条件查询/","link":"","permalink":"http://yoursite.com/2020/07/22/MySQL%E5%9F%BA%E7%A1%80-DQL-%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"MySQL条件_DQL示例表员工表：员工编号、名、姓 、邮箱、电话号码、工种编号、薪水、奖金率、上级领导员工编号、部门编号、入职日期 部门表：部门编号、部门名称、部门领导的员工编号、位置编号 位置表：位置编号、街道、邮编、城市、省份、国家编号 工种表：工种编号、工种名称、最低工资、最高工资 条件查询进阶一：条件查询#进阶2：条件查询 /* 语法： select 查询列表 from 表名 where 筛选条件 分类： 一、按条件表达式筛选 简单条件运算符 &lt; &gt; !=(&lt;&gt;) &lt;= &gt;= 二、按逻辑表达式筛选 逻辑运算符: &amp;&amp; || ! and or not 作用：用于连接条件表达式 三、模糊查询 like between and in is null */ 1. 简单条件运算符&lt; &gt; = &lt;&gt; &lt;=&gt; 安全等于 &lt;= &gt;= #案例一：查询员工工资大于12000的员工信息 select * from employees where employees.salary&gt;12000 #案例二：查询部门编号不等于90号的员工名 和 部门编号 select employees.department_id as 部门编号 ,CONCAT(employees.first_name,&#39; &#39;,employees.last_name) as 姓名 from employees where employees.department_id &lt;&gt; 90 2. 逻辑运算符查询and or not #案例一：工资在10000 到 20000 之间的员工名 、 工资 以及 奖金 select CONCAT(employees.first_name,&#39;.&#39;,last_name) as 姓名, employees.salary as 工资, employees.commission_pct as 奖金 from employees WHERE salary&gt;=10000 and salary&lt;=20000 # 案例二：查询部门编号不是在90到110之间 ， 或者工资高于15000的 员工信息 select * from employees where not (department_id&gt;=90 and department_id&lt;=110) or salary&gt;15000 3. 模糊查询like betweent and is null is nut null like 一般搭配通配符使用，用于判断字符型和数值型, 通配符：%任意多个字符 _任意单个字符 # 三：模糊查询 /* 1.like : 特点：①一般和通配符搭配使用 通配符：% 任意多个字符（包含0个字符） _ 任意单个字符 */ # 案例一：查询员工名中包含字符a的员工信息 select * from employees where last_name LIKE &#39;%a%&#39; #案例二： 查询员工名中第三个字符为e 第五个字符 为a 的员工名和工资 select last_name as 员工名 , salary as 薪水 from employees where last_name like &#39;__n_l%&#39; #案例三：查询员工名中第二个字符为_的员工名 使用转义字符 select last_name from employees WHERE last_name like &#39;_$_%&#39; ESCAPE &#39;$&#39; #2. between and /* 使用between and能提高语句的简洁度 两个临界值的大小顺序不能变换 */ #案例一：查询员工编号在100 到 120 之间的员工信息 select * from employees where employee_id BETWEEN 100 and 120 #三 in：判断某字段的值是否为列表中的某一项 使用in提高语句的简洁度 in列表的值类型 必须统一或兼容 #案例一：查询员工的工种编号是 IT_PROG AD_VP 、 AD_PRES中的一个员工名和工种编号 SELECT last_name as 姓名, job_id as 工种编号 from employees where job_id in(&#39;IT_PROG&#39;,&#39;AD_VP&#39;,&#39;AD_PRES&#39;) # 4. is null 的使用 : 使用等于号(或不等号)不能判断 null 值 #案例一：查询没有奖金的员工名 和 奖金率 select last_name, commission_pct from employees where commission_pct is not null # 安全等于：&lt;=&gt; /* */ select last_name, commission_pct from employees where commission_pct &lt;=&gt; null; select last_name, commission_pct from employees where commission_pct &lt;=&gt; 0.4; #is null 对比 &lt;=&gt; is null :仅可以判断null的值 可读性较好 &lt;=&gt;: 既可以判断null值 又可以判断普通值 可读性较差 ; #案例：查询员工号为176的员工的部门号 姓名和 年薪 select last_name as 姓名, employees.department_id as 部门号, salary*12*(1+IFNULL(commission_pct,0)) as 年薪 from employees where employee_id &lt;=&gt; 176 经典面试题经典面试题： select * from employees 和 select * from employees where commission_pct like &#39;%%&#39; and last_name like &#39;%%&#39; 结果是否一致? 不一致：如果判断的字段值有null 则造成结果丢失 如果用or 有字段必不为空则可以","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"MySQL基础_DQL_基础查询","slug":"MySQL基础-DQL-基础查询","date":"2020-06-03T12:05:35.000Z","updated":"2020-07-22T08:21:59.972Z","comments":true,"path":"2020/06/03/MySQL基础-DQL-基础查询/","link":"","permalink":"http://yoursite.com/2020/06/03/MySQL%E5%9F%BA%E7%A1%80-DQL-%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"MySQL基础_DQL示例表员工表：员工编号、名、姓 、邮箱、电话号码、工种编号、薪水、奖金率、上级领导员工编号、部门编号、入职日期 部门表：部门编号、部门名称、部门领导的员工编号、位置编号 位置表：位置编号、街道、邮编、城市、省份、国家编号 工种表：工种编号、工种名称、最低工资、最高工资 基础查询进阶一：基础查询/* SELECT 查询列表FROM 表; 特点： 查询列表可以为：表中的字段、常量值、表达式、函数 查询的结果为一个虚拟表格 */ use myemployees;1.查询单个字段select last_name from employees;2.查询表中的多个字段select last_name,salary,email from employees;3.查询表中的所有字段select * from employees;4.查询常量值select 100; select &#39;你好啊&#39;;5.查询表达式select 100*158*98; select 100%92;6.查询函数select VERSION();7.为字段取别名/* 便于理解 如果要查询的字段有重名的情况，使用别名可以区分开来 */方式一：使用asselect 100*98 AS 结果; SELECT last_name AS 姓, first_name AS 名 from employees;方式二：使用空格SELECT last_name 姓, first_name 名 from employees;案例：查询salary 显示结果为out put(加上双引号或着重符号)select salary `out put` from employees; select salary &quot;out put&quot; from employees;8.去重案例：查询员工表中涉及的所有部门编号select department_id from employees; select distinct department_id from employees;9.+的作用/* mysql 中的+只为运算符 select 100+90; 两个操作数都为数值型，则做加法运算 select &#39;100&#39; + 90; 其中一方为字符型，试图将字符型数值转为数值型， select &#39;100&#39; + 90; 如果转换成功则，继续做加法运算. select &#39;jone&#39; + 90; 若失败，则将字符型转换为0 select null+10; 只要其中一方为null则结果肯定为null */案例；查询员工名和姓连接成一个字段，并显示为 姓名 concat 函数select last_name+first_name as 姓名 from employees select CONCAT(last_name,&#39; &#39;,first_name) as 姓名 from employees desc departments; SELECT * from departments; select * from employees; select DISTINCT(job_id) from employees;此处 commission_pct 为 null 则结果为nullselect CONCAT(employees.employee_id,&#39;,&#39;,employees.first_name,&#39;,&#39;,employees.last_name,&#39;,&#39;, employees.salary,&#39;,&#39;,employees.phone_number,&#39;,&#39;,employees.manager_id,&#39;,&#39;, employees.job_id,&#39;,&#39;,employees.hiredate,&#39;,&#39;,employees.email ) as &quot;out_put&quot; from employees;判断是否为nullselect IFNULL(employees.commission_pct,0) AS 奖金率 from employees; select CONCAT(employees.employee_id,&#39;,&#39;,employees.first_name,&#39;,&#39;,employees.last_name,&#39;,&#39;, employees.salary,&#39;,&#39;,employees.phone_number,&#39;,&#39;,employees.manager_id,&#39;,&#39;, employees.job_id,&#39;,&#39;,employees.hiredate,&#39;,&#39;,employees.email,&#39;,&#39;,IFNULL(employees.commission_pct,0) ) as &quot;out_put&quot; from employees;补充isnull函数 功能：判断某字段的值是否为null 如果为null 返回1 否则返回0.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"MySQL基础_MySQL常见命令","slug":"MySQL基础-MySQL常见命令-1","date":"2020-06-03T12:04:48.000Z","updated":"2020-06-03T12:04:48.949Z","comments":true,"path":"2020/06/03/MySQL基础-MySQL常见命令-1/","link":"","permalink":"http://yoursite.com/2020/06/03/MySQL%E5%9F%BA%E7%A1%80-MySQL%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-1/","excerpt":"","text":"","categories":[],"tags":[{"name":"xxx","slug":"xxx","permalink":"http://yoursite.com/tags/xxx/"}]},{"title":"MySQL基础_MySQL常见命令","slug":"MySQL基础-MySQL常见命令","date":"2020-06-03T11:53:12.000Z","updated":"2020-06-03T12:03:36.876Z","comments":true,"path":"2020/06/03/MySQL基础-MySQL常见命令/","link":"","permalink":"http://yoursite.com/2020/06/03/MySQL%E5%9F%BA%E7%A1%80-MySQL%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/","excerpt":"","text":"数据库的好处1.持久化数据到本地 2.可以实现结构化查询，方便管理数据库相关概念1、DB：数据库，保存一组有组织的数据的容器 2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 3、SQL:结构化查询语言，用于和DBMS通信的语言数据库存储数据的特点1、将数据放到表中，表再放到库中 2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。 3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。 4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性” 5、表中的数据是按行存储的，每一行类似于java中的“对象”。mysql 服务的启动和停止启动 net start mysql 停止 net start mysqlmysql 服务的登录和退出方式一：通过mysql自带的客户端 只限于root用户 方式二：通过windows自带的客户端（命令行 管理员启动） 登录： mysql 【-h 主机名 -P端口号】-u 用户名 -p密码 退出：exit 或Ctrl + Cmysql 常见命令1.查看当前所有的数据库 show databases; 2.打开指定的库 use 库名 3.查看当前所有的表 show tables; 4.查看其它库的所有表 show tables from 库名; 5.创建表 create table（ 列名 列类型， 列名 列类型 ... ）; 6.查看表结构 desc 表名 7.查看服务器的版本 方式一：登录到mysql服务端 select version（）； 方式二：没有登录到mysql服务端 mysql --version 或 mysql --Vmysql的语法规范1.不区分大小写，但建议关键字大写，表名、列名小写 2.每条命令结尾最好用分号 3.每条命令根据需要，可以进行缩进 或换行 4.注释 单行注释：#注释文字 -- 注释文字 多行注释：/*注释文字....*/SQL的语言分类DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言 insert 、update、delete DDL（Data Define Languge）：数据定义语言 create、drop、alter TCL（Transaction Control Language）：事务控制语言 commit、rollback","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"粗略MVC设计模式一","slug":"粗略MVC设计模式一","date":"2020-02-20T10:43:04.000Z","updated":"2020-02-20T11:39:42.913Z","comments":true,"path":"2020/02/20/粗略MVC设计模式一/","link":"","permalink":"http://yoursite.com/2020/02/20/%E7%B2%97%E7%95%A5MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/","excerpt":"","text":"粗略MVC设计模式一 以点击超链接查询所有的学生为例 示列代码&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;getallstudentservlet&quot;&gt;获得所有学生名单&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; package mvctry; import java.io.IOException; import java.util.Arrays; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import dal.UserDal; /** * Servlet implementation class GetAllStudentServlet */ @WebServlet(&quot;/getallstudentservlet&quot;) public class GetAllStudentServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub //response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath()); UserDal userdal = new UserDal(); request.setAttribute(&quot;students&quot;,userdal.getalluser()); request.getRequestDispatcher(&quot;/allstudent.jsp&quot;).forward(request, response); } } &lt;%@page import=&quot;module.User&quot;%&gt; &lt;%@page import=&quot;java.util.List&quot;%&gt; &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; allstudent:&lt;br&gt;&lt;/br&gt; &lt;% List&lt;User&gt; users = (List)request.getAttribute(&quot;students&quot;); for(User user : users){ out.print(&quot;账号：&quot;+user.getAccount()+&quot; 密码：&quot;+user.getPassword()+&quot; 用户名：&quot;+user.getUsername()); out.print(&quot;&lt;br&gt;&quot;); } %&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;10&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;账号&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;th&gt;Delete &lt;/th&gt; &lt;/tr&gt; &lt;% for(User user:users){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%=user.getAccount() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=user.getUsername() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=user.getPassword() %&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;deleteservlet?useraccount=&lt;%=user.getAccount()%&gt;&quot; &gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 关于MVC M：module V： view jsp在界面上编写java代码 C: controller servlet 受理请求，获取请求参数调用dao方法转发（重定向页面） 受理请求 获取请求参数 调用DAO方法 可能会把DAO方法的返回值放入request中 转发或重定向 何时转发 何时重定向若目标的响应界面不需要从request中读取任何值则可以重定向（还可以防止表单的重复提交） 不足 一个请求一个servlet不好！一个模块使用一个servlet，即多个请求可以使用一个servlet 使用数据库连接池，DButils,JDBCUtils 工具类 DAO基类 在页面上加入jQuery提示","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"},{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"},{"name":"javaweb","slug":"javaweb","permalink":"http://yoursite.com/tags/javaweb/"}]},{"title":"jsp简介","slug":"jsp简介","date":"2020-02-17T08:41:12.000Z","updated":"2020-02-17T09:57:53.894Z","comments":true,"path":"2020/02/17/jsp简介/","link":"","permalink":"http://yoursite.com/2020/02/17/jsp%E7%AE%80%E4%BB%8B/","excerpt":"","text":"JSP(java server page)java服务器端网页，在HTML页面中写java代码的页面 JSP简介： JSP是简化Servlet编写的一种技术，它将java代码和HTML语句混合在同一个文件中编写，只对网页中的要动态产生的内容采用java代码编写，而对固定不变的静态内容采用普通的静态HTML页面的方式编写。 jsp中的代码应该放在body节点下的&lt;%%&gt;中 jsp可以放在web应用程序中除 WEB-INFO的其它任何目录中，jsp的访问格式也与html页面的访问格式完全相同(并不是完全不能，只是不建议，由于该目录下主要放的是一些隐私文件) jsp 运行原理： jsp本质上是一个servlet，jsp程序先编译为servlet文件 然后再进行编译，因此servlet的大部分方法在jsp程序中也能使用。 jsp的9个隐含对象jsp页面的隐含对象一共有9个,隐含对象不需经申明就可以直接使用 1234567891. &lt;font color&#x3D;&quot;red&quot;&gt;request&lt;&#x2F;font&gt;: 为HttpServeletRequest对象 2. response：为HttpServletResponse的对象，在jsp页面中几乎不会使用 3. &lt;font color&#x3D;&quot;red&quot;&gt;pageContext&lt;&#x2F;font&gt;：页面上下文为PageContext的对象，可以从该对象中获取到其它8个隐含对象和其它信息，学习自定义标签时使用 4. &lt;font color&#x3D;&quot;red&quot;&gt;session&lt;&#x2F;font&gt;：代表浏览器和服务器的一次对话，是HttpSession的对象 5. &lt;font color&#x3D;&quot;red&quot;&gt;application&lt;&#x2F;font&gt;: 代表当前应用，能获取当前应用的初始化参数（web.xml中的参数） 6. config：当前jsp对应的servlet的servletConfig对象，若需要访问当前配置的初始化参数需要通过映射来使用，开发的时候几乎不使用![](jsp简介2020_2_17&#x2F;2.png) 7. &lt;font color &#x3D;&quot;red&quot;&gt;out&lt;&#x2F;font&gt;: jspWriter对象，经常使用out.println() 直接将字符串打印到浏览器上 8. page: 指当前jsp对应的servlet对象的引用，但是为Object对象，开发时不使用 9. exception 注意使用exception时必须声明： 以上9个隐含对象均可以在jsp的java代码中使用. pageContext request session application 对属性的作用域范围从小到大 out response config page exception jsp语法jsp中的模板元素jsp中的静态HTML内容 jsp表达式jsp表达式提供了一个将java变量或计算结果输出到客户端的简化方式，它将要输出的变量或表达式直接放在&lt;%= %&gt; 中 jsp脚本片段jsp中的java代码，一个jsp 页面中可以有多个脚本片段，多个脚本片段之间可以相互访问 jsp申明 脚本片段实际上是在方法里的，所以需要声明。jsp申明将java代码封装在&lt;%! %&gt;之中，它里面的代码将被插入到servlet中_jspService方法的外面，不过在jsp页面中，几乎从不使用 jsp注释&lt;%– –%&gt;它与HTML注释的区别是，它可以阻止java代码的执行 和属性相关的方法 方法 Object getAttribute（String name）：获取指定的属性 Enumeration getaAttributeNames（）:获取所有属性的名字组成的Enumeration对象 removeAttribute(String name): 移除指定的属性 void setAttribute（String name , OBject o）:设置属性 pageContext request seeeion application 对象都有这些方法，这四个对象也称之为域对象 pageContext：属性的作用范围仅限于当前jsp页面 request： 属性的作用范围仅限于同一个请求（在有转发的情况下可以跨页面获取当前属性值） session：属性的作用范围限于一次会话（浏览器打开直到关闭称之为一次关闭，在此期间会话不会失效） application：属性的作用范围限于当前web应用。是范围最大的属性作用范围，只要在一处设置属性，在其他各处的JSP或者Servlet中都可以获取到 请求的转发和重定向请求的转发 12345678910//1.请求的转发 /* * 1.调用httpServletRequest 的 getRequestDispatcher方法获取 RequestDispatcher对象 * 调用方法时 需要传入要转发的地址 * 2.调用HTTPServletRequest 的Forward（request，response）方法进行请求的转发. * */ String path = \"testservlet\"; RequestDispatcher requestdispatcher = request.getRequestDispatcher(\"/\"+path); requestdispatcher.forward(request, response); 请求的重定向 12345 //1.请求的重定向调用 response的SendRedirect（path） 方法 String path=\"testtwoservlet\"; response.sendRedirect(path);// 注意路径 本质区别 请求的转发是只发出一次请求，而重定向则发出了两次请求。 具体区别 请求的转发地址栏为初次请求的地址 重定向地址栏不再是除此请求发出的地址，是最后请求的地址 请求转发：在最终的servlet，request对象和中转的request对象是同一个 请求的重定向则不是 请求转发只能转发到当前web应用的资源，而重定向到任何资源 请求的转发：/ 代表当前web应用的根目录 ​ 请求的重定向： / 代表当前web站点的根目录 注意：http://localhost:8084/Day_2_16/a.jsp jsp指令12&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; 以上为jsp指令，jsp指令只是告诉引擎如何处理jsp页面的其它部分 当前主要有page include taglib三种指令 page指令用于定义jsp页面的各种属性，无论page指令出现在哪，它作用的范围都是整个jsp页面，page指令一般放在jsp页面的起始位置 page指令用于定义jsp页面的各种属性，无论page指令出现在哪，它作用的范围都是整个jsp页面，page指令一般放在jsp页面的起始位置 如 【language=“java”】 【extends=”package.class”】 【session=”true|false”】 【isErrorPage=”true|false”】 【errorPage=”true|false”】 import指令：指定当前jsp页面要导入的类包 session指令：指定当前页面是否可用session变量，也可以说访问当前页面时是否可以生成httpsession对象 errorpage 和iserrorpage,errorpage 指定当前页面出现错误的实际响应页面时什么，其中/代表当前web应用的根目录，在响应errorpage时，服务器采用的是请求转发的方式 1&lt;%@ page errorPage=\"error.jsp\" %&gt; iserrorpage指定当前页面是否为错误处理页面，可以说明当前页面是否可以使用exception对象，一般建议错误页面不能够直接访问到错误页面（将当前页面放入 WEB-INF目录下），除此之外还可以在web.xml文件内配置错误页面 1234&lt;error-page&gt;&lt;!--指定错误代码响应，404找不到资源，500内部错误。。。 还可以安异常类型来指定。--&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/error.jsp&lt;/location&gt; &lt;/error-page&gt; 一般而言，WEB-INF下的文件是不能通过直接输入地址的形式来访问的，一般通过请求的转发来访问。 contenttype 指定当前警示牌页面的响应类型，实际调用的是response.setContentType(“text/html;charset:UTF-8”),通常情况下，对于jsp页面其取值均为“text/html;charset:UTF-8” charset指定返回的页面的字符编码是什么，通常取值UTF-8 pageEcoding 指定当前jsp页面的的字符编码，通常情况下也contentType中的charset的值一样。 isELIgnored 指定当前jsp页面是否可以使用EL表达式，通常取值为true include指令用于通知jsp引擎，在翻译当前jsp页面时，将其它文件的内容合并到当前jsp文件的servlet源文件中，当前jsp页面与静态引入的页面紧密结合为一个servlet 12345678&lt;b&gt;aaaaaaaaaaaaaaa&lt;/b&gt;&lt;%-- 在a.jsp中包含b.jsp file如无/ 则相对于当前文件 否则表示当前web应用的根目录--%&gt;&lt;%@ include file=\"b.jsp\"%&gt; 在a.jsp的源文件中已经包含b中的代码 jsp标签 jsp标签用于把另外一个元素的内容插入到当前jsp页面的输出内容之中，这种在jsp页面执行时的引入方法称之为动态引入 iclude 标签 1&lt;jsp:include page = \"b.jsp\"&gt;&lt;/jsp:include&gt; 动态引入：并不是像include指令一样生成一个servlet源文件，而是生成两个servlet源文件，然后通过一个方法的方式把另一个页面包含进来 include指令和jsp:include 标签 标签是在当前页面执行期间插入被引入的内容，被动态引入的资源必须是一个能独立被WEB容器调用和引用的资源 include只能引入遵循jsp格式的文件，被引入的文件与当前jsp文件共同翻译为一个servlet源文件 forward标签1&lt;jsp:forward page=\"b.jsp\"&gt;&lt;/jsp:forward&gt; 相当于请求的转发 123&lt;%request.getRequestDispatcher(\"/b.jsp\").forward(request,response);%&gt; 但是使用jsp forward标签可以使用jsp:param 向字标签传入一些参数，jsp:include 也可以 123&lt;jsp:forward page=\"b.jsp\"&gt;&lt;jsp:param value=\"abac\" name=\"username\"/&gt;&lt;/jsp:forward&gt; ​ 在b.jsp页面内可以通过request.getparamter(“username”)来获取传入的参数 jsp中文乱码问题 在jsp页面上输入中文，请求页面后不出现乱码：保证 charset和pageEncoding的值一致，且都支持中文，一般取值UTF-8,还需保证浏览器显示的字符编码也和请求的jsp页面的编码一致 获取中文参数值：默认参数在传输过程中使用的编码为ISO-8859-1 对于post请求，在获取请求信息之前，先调用request.setCharacterEncoding()即可 对于get请求，前面的方式无效，应采用先解码再进行编码的方式 可以通过修改tomcat的server.xml文件的方式 遇到的错误 tomcat 端口频繁被占用的问题 最有效直接的方法通过任务管理器结束java虚拟机进程 eclipse卡顿问题 关闭自动构建 关闭自动保存 经常出现配置servlet时 类路径正确但是抛异常找不到类 有未生成.class字节文件的可能 开启自动编译但是并没有自动编译 要说没有编译但是Web-INF/classes目录下已经有该文件 解决方法：更换编辑器一致性级别 重新编译 参考：https://blog.csdn.net/qq_21454973/article/details/79481197","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"HTML简介","slug":"HTML简介","date":"2020-01-10T10:00:10.000Z","updated":"2020-01-10T10:31:52.804Z","comments":true,"path":"2020/01/10/HTML简介/","link":"","permalink":"http://yoursite.com/2020/01/10/HTML%E7%AE%80%E4%BB%8B/","excerpt":"","text":"HTML是超文本标记语言。纯文本中，只能保存纯文本内容，图片，音频，视屏等内容都不能保存，网页为纯文本。 标准格式12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt; &lt;!-- html版本声明 编写网页时， 一定要将h5的文档声明写在网页的最上端。避免有些浏览器无法解析该网页 --&gt; &lt;!-- html根标签，一个页面中只有一个根标签，网页中所有内容都在根标签中 --&gt;&lt;html&gt; &lt;!-- head标签用于帮助浏览器解析页面 --&gt; &lt;head&gt; &lt;!-- 标题，默认会显示在浏览器的标题栏中 搜索引擎在检索页面时，会首先检索title中的内容 它是网页中对于搜索引擎来说是最终要的内容，会影响在网页在搜索引擎中的排名 --&gt; &lt;title&gt;这个是我的第一个网页&lt;/title&gt; &lt;/head&gt; &lt;!-- 用于设置网页的主体内容，网页中所有可见的内容，都应该在body中编写 --&gt; &lt;body&gt; &lt;!--注释--&gt; &lt;!-- 属性： 可以通过属性来设置标签，如果处理标签中的可以在开始标签中添加属性 属性需要写在开始标签中，实际上是一个名值对的结构 一个标签中可以使用多个属性 属性名 = “属性值” --&gt; &lt;h1&gt;这是我的&lt;font color= \"lightblue\" size = \"6\"&gt;第一个&lt;/font&gt;网页！&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 标签元素完整的标签为元素 属性进制HTML和css乱码问题 乱码出现的原因：编码解码采用的字符集不一致 字符集：编码和解码所采用的规则，我们成为字符集常见字符集：ASCⅡ 、 ISO8859-1 、 GBK 、 GB2312（中文编码） 、 UTF-8（全球通用）","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"前端基础","slug":"前端基础","date":"2020-01-10T10:00:00.000Z","updated":"2020-02-20T10:49:27.245Z","comments":true,"path":"2020/01/10/前端基础/","link":"","permalink":"http://yoursite.com/2020/01/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"C/S和B/S目前市面上的软件架构分为C/S架构和B/S架构 C/S架构： 一般使用的软件都是C/S架构 比如系统软件中的360、QQ、ofice、等 C表示客户端，用户通过客户端来使用软件 S表示服务器，服务器负责处理软件的业务逻辑特点： 软件使用前必须得安装 软件更新时，服务器和客户端得同时更新 C/S架构不能跨平台使用 各自平台对应各自版本 C/S架构的软件客户端和服务通信采用的是自有的协议，相对来说比较安全 B/S架构 B/S本质上也是C/S，只不过B/S架构的软件，通过使用浏览器作为软件的客户端 B/S架构的软件通过使用浏览器访问网页的形式，来使用软件 比如：京东，淘宝，知乎等特点： 软件不需要安装，直接使用浏览器访问指定的网页即可 软件更新时，客户端不需要更新 软件可以跨平台，只要系统中有浏览器，就可以使用 B/S架构的软件，客户端和服务器之间通信采用的是通用的HTTP协议，相对来说不安全。HTTPS协议相对来说比HTTP更加安全 结构-HTML用于描述页面的结构 表现-CSS用于控制页面元素的样式 行为-JavaScript用于响应用户操作","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-10T07:21:07.658Z","updated":"2020-01-10T07:21:07.658Z","comments":true,"path":"2020/01/10/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}